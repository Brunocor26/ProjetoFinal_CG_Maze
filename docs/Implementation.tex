\chapter{Desenvolvimento e Implementação} \label{chap:implementacao}

Este capítulo descreve a gestão do projeto, a arquitetura do código, e as principais funcionalidades implementadas.

\section{Gestão do Projeto} \label{sec:impl_gestao}

\subsection{Estrutura de Diretórios}
O projeto está organizado da seguinte forma:

\begin{itemize}
    \item \texttt{src/}: Código fonte C++ (.cpp)
    \item \texttt{include/}: Ficheiros de cabeçalho (.h, .hpp)
    \item \texttt{shaders/}: Shaders GLSL (vertex e fragment shaders)
    \item \texttt{assets/}: Recursos (texturas, fontes)
    \item \texttt{build/}: Diretório de compilação (gerado pelo CMake)
    \item \texttt{docs/}: Documentação do projeto
\end{itemize}

\subsection{Sistema de Compilação}
O projeto utiliza CMake para gestão da compilação. O ficheiro \texttt{CMakeLists.txt} define:

\begin{itemize}
    \item Dependências externas (GLFW, FreeType, OpenGL)
    \item Dois executáveis distintos: \texttt{maze\_host.exe} e \texttt{maze\_client.exe}
    \item Ficheiros fonte comuns partilhados entre ambos os executáveis
    \item Comandos personalizados para cópia de shaders e assets para o diretório de compilação
\end{itemize}

\subsection{Carregamento de Assets Portável}
Para garantir que o jogo funciona corretamente em qualquer máquina, foi implementado um sistema de carregamento de assets portável.

\begin{itemize}
    \item O ficheiro \texttt{configuration/root\_directory.h.in} define uma variável \texttt{logl\_root} que aponta para o diretório de assets.
    \item Esta variável foi configurada para \texttt{"."} (diretório atual), o que permite que o jogo procure assets relativamente ao executável.

    \item O CMake copia automaticamente as pastas \texttt{assets} e \texttt{shaders} para junto do executável na pasta \texttt{build}.
    \item A classe \texttt{FileSystem} utiliza este caminho relativo para resolver todos os caminhos de ficheiros em tempo de execução.
\end{itemize}

A separação em dois executáveis permite executar o jogo em modo host e cliente simultaneamente para testar funcionalidades de rede.

\section{Descrição do Código} \label{sec:impl_codigo}

\subsection{Classe Game}
A classe \texttt{Game} é o núcleo da aplicação, responsável pela gestão do ciclo de vida do jogo. Localizada em \texttt{src/Game.cpp} e \texttt{include/Game.h}, implementa os seguintes métodos principais:

\begin{itemize}
    \item \texttt{Init()}: Inicialização de recursos (shaders, geometria, texturas, rede)
    \item \texttt{ProcessInput(float dt)}: Processamento de entrada do teclado e rato
    \item \texttt{Update(float dt)}: Lógica do jogo (networking, deteção de proximidade ao portal)
    \item \texttt{Render()}: Renderização da cena 3D
    \item \texttt{ProcessMouseMovement()}: Controlo de câmara com o rato
    \item \texttt{CheckPortalProximity()}: Verificação de proximidade ao portal de saída
\end{itemize}

A classe gere também o estado do jogo incluindo:
\begin{itemize}
    \item Modo de jogo (HOST ou CLIENT)
    \item Estado de pausa
    \item Estado do diálogo introdutório
    \item Bloqueio de movimento (para modo cliente)
    \item Sockets de rede para comunicação
\end{itemize}

\subsection{Classe Maze}
A classe \texttt{Maze} (\texttt{src/Maze.cpp}, \texttt{include/Maze.h}) é responsável pela representação e renderização do labirinto. Principais funcionalidades:

\begin{itemize}
    \item \texttt{Generate(int width, int height)}: Gera um novo labirinto com recurso ao algoritmo de Kruskal
    \item \texttt{Draw(Shader \&shader)}: Renderiza paredes e chão do labirinto
    \item \texttt{IsWall(float x, float z)}: Deteção de colisões com paredes
    \item Armazena a grelha do labirinto (matriz 2D de inteiros)
    \item Gere os \textit{meshes} de parede e chão
\end{itemize}

\subsection{Classe Camera}
A classe \texttt{Camera} (\texttt{include/learnopengl/camera.h}) implementa uma câmara em primeira pessoa com os seguintes recursos:

\begin{itemize}
    \item Movimento WASD para navegação
    \item Rotação da câmara com o rato
    \item Cálculo de matriz de visualização (\textit{view matrix})
    \item Vetores direcionais (frente, direita, cima)
    \item Campo de visão ajustável (\textit{zoom})
\end{itemize}

\subsection{Classe Shader}
A classe \texttt{Shader} (\texttt{include/Shader.h}) encapsula a gestão de programas shader GLSL:

\begin{itemize}
    \item Carregamento e compilação de vertex e fragment shaders
    \item Ligação (\textit{linking}) de programa shader

    \item Métodos utilitários para definição de uniformes (matrizes, vetores, valores escalares)
    \item Validação de erros de compilação
\end{itemize}

\subsection{Geração de Labirinto: Algoritmo de Kruskal}
A classe \texttt{maze::kruskal} (\texttt{include/kruksal/kruksal.cpp}) implementa o algoritmo de Kruskal para geração procedural de labirintos perfeitos (sem ciclos).

\textbf{Nota de Atribuição}: A implementação do algoritmo de Kruskal foi adaptada do repositório de Ferenc Nemeth \cite{MazeAlgorithms}, que fornece implementações de referência de vários algoritmos de geração de labirintos em C++.

\textbf{Funcionamento do algoritmo}:
\begin{enumerate}
    \item Inicializa cada célula como um conjunto disjunto
    \item Cria lista de todas as paredes possíveis entre células adjacentes
    \item Baralha aleatoriamente a lista de paredes
    \item Para cada parede:
    \begin{itemize}
        \item Se as células adjacentes pertencem a conjuntos diferentes
        \item Remove a parede
        \item Une os conjuntos
    \end{itemize}
    \item Continua até que todas as células pertençam ao mesmo conjunto
\end{enumerate}

Este método garante que existe sempre um caminho único entre quaisquer dois pontos do labirinto.

\subsection{Classe TextRenderer}
A classe \texttt{TextRenderer} (\texttt{src/TextRenderer.cpp}) utiliza FreeType para renderização de texto:

\begin{itemize}
    \item \texttt{Load(std::string font, unsigned int fontSize)}: Carrega fonte TrueType
    \item \texttt{RenderText()}: Renderiza texto 2D sobre a cena 3D
    \item Gera texturas de caracteres dinamicamente
    \item Utiliza projeção ortográfica para renderização 2D
\end{itemize}

\subsection{Classe Mesh}
A classe \texttt{Mesh} (\texttt{include/Mesh.hpp}) encapsula geometria 3D:

\begin{itemize}
    \item Armazena vértices (posição, normal, coordenadas de textura)
    \item Gere VAO, VBO para renderização eficiente
    \item Suporta múltiplas texturas (difusa, normal, rugosidade)
    \item Método \texttt{Draw()} para renderização
\end{itemize}

\subsection{Módulo Network}
As funções de networking (\texttt{src/network.cpp}, \texttt{include/Network.h}) implementam comunicação TCP:

\begin{itemize}
    \item \texttt{createSocket()}: Cria socket TCP
    \item \texttt{bindAndListen()}: Inicia servidor (modo host)
    \item \texttt{acceptConnection()}: Aceita ligação de cliente
    \item \texttt{connectToServer()}: Liga ao servidor (modo cliente)
    \item \texttt{sendData()}, \texttt{receiveData()}: Transferência de dados
    \item \texttt{closeSocket()}: Encerramento de ligação
\end{itemize}

\section{Funcionalidades Implementadas} \label{sec:impl_funcionalidades}

\subsection{Geração Procedural de Labirintos}
Cada execução do jogo gera um labirinto único através do algoritmo de Kruskal. O tamanho do labirinto é configurável (atualmente 15x15 células).

\subsection{Sistema de Iluminação Dinâmica}
O jogo implementa um sistema de iluminação tipo lanterna (\textit{flashlight/spotlight}) através de shaders GLSL personalizados:


\begin{itemize}
    \item \textbf{Spotlight}: A luz segue a posição e direção da câmara
    \item \textbf{Atenuação}: Diminuição gradual da intensidade luminosa com a distância
    \item \textbf{Ângulos de corte}: Controlo do cone de luz (ângulo interno e externo)
    \item \textbf{Fog Effect}: Névoa atmosférica que esconde geometria distante
\end{itemize}

O vertex shader (\texttt{shaders/maze\_vs.glsl}) transforma vértices e calcula posições para iluminação. O fragment shader (\texttt{shaders/maze\_fs.glsl}) implementa o modelo de iluminação de Phong modificado com características de spotlight.


\begin{figure}[h]
    \centering
    \includegraphics[width=0.8\textwidth]{figures/lighting_flashlight.png}
    \caption{Efeito de lanterna (Spotlight) e atenuação da luz nas paredes do labirinto.}
    \label{fig:lighting}
\end{figure}

\subsection{Networking Host/Cliente}
O jogo suporta dois modos de execução:

\textbf{Modo HOST}:
\begin{itemize}
    \item Inicia servidor TCP na porta 8080
    \item Aguarda ligação de cliente
    \item Ao atingir o portal, envia mensagem "UNLOCK" ao cliente
    \item Permite movimento livre desde o início
\end{itemize}

\textbf{Modo CLIENT}:
\begin{itemize}
    \item Liga ao servidor host (127.0.0.1:8080)
    \item Movimento bloqueado até receber mensagem "UNLOCK"
    \item Após desbloqueio, pode navegar até ao próprio portal
    \item Apresenta sequência de fim ao atingir portal
\end{itemize}

\subsection{Sistema de Diálogo Introdutório}
Ao iniciar o jogo, é apresentado um diálogo com:
\begin{itemize}
    \item Mensagem de boas-vindas
    \item Indicação do modo de jogo (HOST/CLIENT)
    \item Objetivo do jogo
    \item Controlos disponíveis
    \item Instrução para pressionar ENTER e iniciar
\end{itemize}

Durante a apresentação do diálogo, a entrada de movimento é ignorada.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.7\textwidth]{figures/intro_dialog.png}
    \caption{Menu introdutório renderizado com FreeType sobre a cena 3D.}

    \label{fig:intro}
\end{figure}

\subsection{Ambiente Exterior}
Para além do labirinto, o jogo inclui:

\begin{itemize}
    \item \textbf{Plano de relva}: Superfície texturizada que estende 10 células além do labirinto
    \item \textbf{Árvores procedurais}: Árvores simples compostas por tronco (cilindro) e copa (pirâmide)
    \item \textbf{Portal de saída}: Esfera flutuante com efeito visual de "Mercúrio Líquido/Prata" (\textit{Liquid Silver}), gerado proceduralmente via shaders GLSL, que pulsa e brilha, e atua como o objetivo final do jogo.
\end{itemize}

\begin{figure}[h]
    \centering
    \includegraphics[width=0.8\textwidth]{figures/outdoor_trees.png}
    \caption{Ambiente exterior mostrando as árvores procedurais e o portal ao fundo.}
    \label{fig:outdoor}
\end{figure}

\subsection{Deteção de Colisões}
O sistema de colisões verifica:
\begin{itemize}
    \item Interseção do jogador com paredes do labirinto
    \item Movimento é bloqueado em direções que causariam colisão
    \item Permite movimento deslizante ao longo de paredes
    \item \textbf{Prevenção de Clipping}: Implementado um raio de colisão (\texttt{playerRadius = 0.3f}) em torno da câmara para impedir que o plano de visualização atravesse as esquinas das paredes.

\end{itemize}

\subsection{Sistema de Pausa}
Pressionando a tecla ESC:
\begin{itemize}
    \item O jogo pausa/despausa
    \item Cursor do rato torna-se visível (modo pausa)
    \item Movimento e rotação da câmara são bloqueados
\end{itemize}

\begin{figure}[h]
    \centering
    \includegraphics[width=0.7\textwidth]{figures/pause_screen.png}
    \caption{Overlay de Pausa renderizado quando o jogador pressiona ESC.}
    \label{fig:pause}
\end{figure}

\subsection{Transição de Cor Progressiva}
Uma funcionalidade adicional implementada é a transição gradual da cor do ambiente à medida que o jogador se aproxima do portal. Este efeito visual cria feedback atmosférico e ajuda o jogador a perceber a proximidade ao objetivo.


\textbf{Implementação}:
\begin{itemize}
    \item Cálculo da distância entre câmara e portal
    \item Normalização da distância (0-1) em relação à largura total do labirinto
    \item Aplicação de \textit{smoothstep} para interpolação suave
    \item Transição de branco (normal) para roxo/místico (próximo do portal)
    \item Aplicação do \textit{tint} no fragment shader antes do efeito de névoa
\end{itemize}

A função \texttt{GetEnvironmentTint()} calcula o fator de interpolação usando a fórmula:
\begin{equation}
t = t^2(3 - 2t)
\end{equation}

Este \textit{smoothstep} garante uma transição visual suave, sem mudanças abruptas de cor.

\subsection{Shader de Metal Líquido (Portal)}
Para criar o efeito do portal "Mercúrio Líquido", foi implementado um shader procedural em GLSL que substitui a renderização de texturas padrão quando a flag \texttt{isPortal} está ativa.

\textbf{Características do efeito}:
\begin{itemize}
    \item \textbf{Animação Procedural}: Combinação de três ondas sinusoidais (\texttt{sin/cos}) com frequências e fases diferentes, animadas pelo tempo (\texttt{uniform float time}), o que cria um padrão fluido e orgânico.
    \item \textbf{Efeito Fresnel}: As bordas da esfera são iluminadas intensamente (efeito de borda/rim light) baseado no ângulo de visão (\texttt{dot(viewDir, normal)}), o que simula um material metálico ou energético.
    \item \textbf{Cores}: Mistura de uma base prateada azulada \texttt{(0.7, 0.75, 0.8)} com tons de branco puro nos picos das ondas e um leve brilho ciano nas bordas.
    \item \textbf{Pulsação}: A intensidade global da cor oscila com o tempo, o que dá a impressão de um objeto "vivo".
\end{itemize}

\begin{figure}[h]
    \centering
    \includegraphics[width=0.7\textwidth]{figures/portal_effect.png}
    \caption{Renderização do Portal com efeito "Mercúrio Líquido" e iluminação Fresnel.}
    \label{fig:portal_effect}
\end{figure}

\subsection{Texturas e Materiais}
O jogo utiliza texturas PBR (Physically-Based Rendering) de alta qualidade (4K):

\begin{itemize}
    \item \textbf{Paredes}: Textura de tijolos (Bricks101) com mapas de cor, normal e rugosidade
    \item \textbf{Chão}: Textura de pedras pavimentadas (PavingStones138)
    \item \textbf{Exterior}: Textura de relva (Grass005)
\end{itemize}

\subsection{Minimapa (HUD)}
Foi implementado um minimapa 2D no canto superior direito do ecrã para auxiliar a navegação do jogador.

\textbf{Implementação Técnica}:
\begin{itemize}
    \item \textbf{Renderização}: Utiliza um shader simples (\texttt{simpleShader}) que desenha apenas cores sólidas, sem texturas ou iluminação.
    \item \textbf{Projeção}: Usa uma matriz de projeção ortográfica (\texttt{glm::ortho}) para mapear coordenadas de ecrã (pixels) diretamente, ignorando-se a perspetiva 3D.
    \item \textbf{Conteúdo}:
    \begin{itemize}
        \item \textbf{Fundo}: Retângulo cinzento escuro semitransparente.

        \item \textbf{Labirinto}: Itera sobre a estrutura de dados \texttt{grid} do labirinto e desenha quadrados pretos para cada parede.
        \item \textbf{Jogador}: Um quadrado vermelho representa a posição atual da câmara, atualizada em tempo real.
    \end{itemize}
\end{itemize}

O minimapa ignora o \textit{Depth Test} durante a sua renderização para garantir que aparece sempre sobreposto à cena 3D (HUD).


\begin{figure}[h]
    \centering
    \includegraphics[width=0.7\textwidth]{figures/minimap.png}
    \caption{Interface de jogo com o Minimapa no canto superior direito, mostrando a posição do jogador (vermelho) e as paredes (preto).}
    \label{fig:minimap}
\end{figure}

\section{Documentação com Doxygen} \label{sec:impl_doxygen}
Todas as classes e ficheiros de cabeçalho do projeto foram documentados utilizando o formato Doxygen. Isto inclui descrições detalhadas de:
\begin{itemize}
    \item Classes principais (\texttt{Game}, \texttt{Maze}, \texttt{Camera})
    \item Utilitários (\texttt{Objloader}, \texttt{Texture}, \texttt{TextRenderer})
    \item Estruturas de dados e definições de tipos
\end{itemize}

A documentação HTML pode ser gerada executando o comando:
\begin{lstlisting}[language=bash, numbers=none]
doxygen Doxyfile
\end{lstlisting}

Esta documentação técnica facilita a manutenção futura e a compreensão da arquitetura por novos programadores.

